# 2019/04/08

##### 2.4 NumPy #####
# 内部はC言語で実装されているため高速に動作する
# 大規模な数学関数ライブラリを持っており，演算機能が充実している．



##### 2.4.1 NumPyのインポート #####
import numpy as np



##### 2.4.2 NumPyの配列 #####
# NumPyの配列は，attay関数を使うことでPythonのリストから簡単につくることができる
a = np.array([0, 1, 2, 3, 4, 5])
print(a)
# [0 1 2 3 4 5]

# 配列が折り重なった，2次元配列を作ることもできる．
b = np.array([[0, 1, 2], [3, 4, 5]]) # リストのリストを渡す
print(b)
# [[0 1 2]
#  [3 4 5]]

# 同様に，3次元の配列も作ることができる．
c = np.array([[[0, 1, 2], [3, 4, 5]], [[5, 4, 3], [2, 1, 0]]])
print(c)
# [[[0 1 2]
#    3 4 5]]
#
#  [[5 4 3]
#    2 1 0]]]

# 同様にして，より多次元の配列を作ることもできる．
# 配列の形状(各次元の要素数)はshape関数で，
# 配列のトータルの要素数はsize関数で得ることができる．
print(np.shape(c))
print(np.size(c))
# (2, 2, 3)
# 12

# リストの要素数をカウントするlen関数は，配列に使用すると最初の次元の要素数をカウントする．
d = [[1,2],[3,4],[5,6]] # (3, 2)の形状を持つリスト
print(len(d))
print(len(np.array(d)))
# 3
# 3



##### 2.4.3 配列を生成するさまざまな関数 #####
print(np.zeros(10)) # 要素がすべて0の配列
print(np.ones(10)) # 要素がすべて1の配列
print(np.random.rand(10)) # 乱数の配列

# このうち，zeros関数とones関数は引数にタプルを指定することができる．
print(np.zeros((2, 3)))
print(np.ones((2, 3)))
# [[ 0. 0. 0.]
#  [ 0. 0. 0.]]
# [[ 1. 1. 1.]
#  [ 1. 1. 1.]]

# arange関数を用いると，連続した数値を要素にもつ配列を作ることができる．
print(np.arange(0, 1, 0.1))
# [0. 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9]
print(np.arange(10))
# [0 1 2 3 4 5 6 7 8 9]

# arange関数と似た関数に，linspace関数がある．
# arange関数との違いは，第3引数が刻み幅ではなく要素数である点．
# linspace関数の機能は，グラフにおける横軸の値などを表現するのに用いられる．
print(np.linspace(0, 1, 11))
# [0. 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.]



# 2019/04/12

##### 2.4.4 reshapeによる形状の変換 #####
# 要素数が8の１次元配列を，形状が(2,4)の２次元配列に変換．
a = np.array([0, 1, 2, 3, 4, 5, 6, 7])
b = a.reshape(2, 4)
print(b)
# [[0 1 2 3]
#  [4 5 6 7]]

# reshapeは配列が持っているメソッドであることに注意
# NumPyには同じ操作を関数とメソッドの両方で行うことができるという特徴がある．
# 以下のように，関数のreshapeｗｐ使っても結果は同じになる．
b = np.reshape(a, (2, 4))

# トータルの要素数さえあっていれば，どのような形状でもreshapeで変換できる．
# reshapeの引数を-1とすると，どのような形状の配列でも１次元配列に変換できる．
c = a.reshape(2, -1)
print(c)
# [[0 1 2 3]
#  [4 5 6 7]]



##### 2.4.5 配列の演算 #####
a = np.array([0, 1, 2, 3, 4, 5]).reshape(2, 3) # 2行3列の配列を作成
print(a)
print(a + 3) # 各要素に3を足す
print(a * 3) # 各要素の3を掛ける

# 基本的に演算に使用する配列の形状は同じでないとエラーになる
b = np.array([5, 4, 3, 2, 1, 0]).reshape(2, 3)
print(b)
print(a + b) # 配列同士の足し算
print(a * b) # 配列同士の掛け算


##### 2.4.6 ブロードキャスト #####
# NumPyでは，特定の条件を満たしていれば違う形状の配列同士でも演算を行うことができる．
# この機能をブロードキャストという．

a = np.array([  [1, 1],
                [1, 1]] ) # ２次元配列
b = np.array([1, 2]) # １次元配列
# これらの2つの配列は次元が違うが，ブロードキャストにより演算することができる．
# (1次元配列が縦方向に拡張されることにより，同じ形状を有する2次元配列同士の演算が行われたことになる．)
print(a + b) # 次元が違う配列同士の足し算
# [[2 3]
#  [2 3]]

c = np.array([  [1],
                [2] ]) # 形状が(2, 1)の2次元配列
print(a + c)
# [[2 2]
#  [3 3]]

# 以上のように，ある方向に拡張することで配列の形状が一致すれば，
# ブロードキャストにより形状が異なる配列同士でも演算が可能．



# 2019/04/14

##### 2.4.7 要素へのアクセス #####
# 先頭から0, 1, 2...とインデックスをつけた場合の，インデックスが2の要素を取り出す．
a = np.array([0, 1, 2, 3, 4, 5])
print(a[2]) 
# 2

# 要素の入れ替え
a[2] = 9
print(a)
# [0, 1, 9, 3, 4, 5]

# 2次元配列の場合，要素を取り出す際にはインデックスを縦横で2つ指定する．
# 以下の例では，縦のインデックスが１，横のインデックスが２の要素を取り出している．
b = np.array(   [[0, 1, 2],
                 [3, 4, 5]])
print(b[1, 2]) # b[1][2]と同じ
# 5

# 3次元以上の配列の場合も同様に，インデックスを複数指定することで要素にアクセスできる．
# 指定するインデックスの数が配列の次元の数より少ない場合，配列の一部にアクセスする．
# 以下の例では，２次元配列であるにもかかわらず，インデックスを１つしか指定していない．
# この場合，最初の次元のインデックスが１の要素が配列として取り出される．
c = np.array(   [[0, 1, 2],
                 [3, 4, 5],
                 [6, 7, 8]])
print(c[1]) # インデックスを１つだけ指定する
# [3 4 5]

# 同様に，インデックスを指定して，要素を指定した配列で置き換えることができる．
c[1] = np.array([9, 10, 11]) # 要素を配列で置き換える
print(c)
# [[0  1  2]
#  [9 10 11]
#  [6  7  8]]

# また，以下のように，[]内に条件を記述すると，条件を満たす要素のみを取り出すことができる．
d = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
print(d[d%2 == 0]) # []内に条件を記述
# [0 2 4 6 8]

# なお，インデックスに配列を用いることもできる．
# この場合，複数の要素にまとめてアクセスすることができる．
# 以下の例では，２つの配列でインデックスを指定して，配列eの複数の要素を入れ替えている．
e = np.zeros((3, 3))) # 2次元配列，要素はすべて0
f = np.array([8, 9]) # 置き換える値

e[np.array([0, 2]), np.array([0, 1]) ] = f # ２つの配列でインデックスを指定
# [[8. 0. 0.]
#  [0. 0. 0.]
#  [0. 9. 0.]]



##### 2.4.8 スライシング #####
# NumPyのスライシング機能を用いると，配列の一部を自由に取り出したり入れ替えたりすることができる．
a = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
print(a[2:8]) # ２番目から７番目の要素を抽出
# [2 3 4 5 6 7]
# 要素へのアクセスとは異なり，抜き出した配列の次元は，元の配列の次元と変わらない．

print(a[2:8:2]) # ステップを指定する
# [2 4 6]

print(a[:]) # すべての要素を指定する
# [0 1 2 3 4 5 6 7 8 9]

# ２次元配列の場合，カンマで区切って各次元の範囲を指定する．
# 以下の例では，配列bから左上の2×2の領域を取り出している．
b = np.array( [[0, 1, 2],
               [3, 4, 5],
               [6, 7, 8]])
print(b[0:2, 0:2]) # 各次元の範囲を指定
# [[0 1]
#  [3 4]]

# スライシングを用いて指定した領域を置き換えることができる．
# 配列bの左上，2×2の領域を置き換えてみる．
b[0:2, 0:2] = np.array([[9, 9],
                        [9, 9]])
print(b)
# [[9 9 2]
#  [9 9 5]
#  [6 7 8]]

# ３次元の場合
c = np.zeros(18).reshape(2, 3, 3)
print(c)
# [[[0. 0. 0.]
#   [0. 0. 0.]
#   [0. 0. 0.]]
#
#  [[0. 0. 0.]
#   [0. 0. 0.]
#   [0. 0. 0.]]]

# スライシングによる範囲の置き換え(３次元配列)
c[0, 0:2, 0:2] = np.ones(4).reshape(2, 2)
print(c)
# [[[1. 1. 0.]
#   [1. 1. 0.]
#   [0. 0. 0.]]
#
#  [[0. 0. 0.]
#   [0. 0. 0.]
#   [0. 0. 0.]]]



##### 2.4.9 軸とtransposeメソッド #####
# NumPyには軸(axis)という概念がある．
a = np.array([[0, 1, 2],
              [3, 4, 5]])
print(a)
#   axis=1 
# --------->
# [[0 1 2]
#  [3 4 5]]

# 軸にはそれぞれインデックスがある．
# ２次元配列の場合，縦方向の軸はaxis=0で，横方向の軸はaxis=1となる．
# transposeで配列の軸を入れ替えることができる．
print(a.transpose(1, 0)) # 軸を入れ替える
print(a.T) # 転置
#   axis=1
# ------->
# [[0 3]
#  [1 4]
#  [2 5]]

# ２次元配列を２つ奥行き方向(axis=0)に並べて３次元配列を表現している．
b = np.array(12).reshape(2, 2, 3)
print(b)
# [[[0  1  2]
#   [3  4  5]]
#
#  [[6  7  8]
#   [9 10 11]]]

print(b.transpose(1, 2, 0))
# [[[0  6]
#   [1  7]
#   [2  8]]
#
#  [[3  9]
#   [4 10]
#   [5 11]]]



##### 2.4.10 NumPyの関数 #####
# sum関数
a = np.array([[0, 1],
              [2, 3]])
print(np.sum(a))
# 6

# NumPyのいくつかの関数は，引数にaxisを設定することで特定の軸方向に演算を行うことができる．
print(np.sum(a, axis=0))
# [2 4]

print(np.sum(a, axis=1))
# [1 5]

# axisを指定すると上記のように配列の次元が１つ減るが，
# 引数にkeepdims=Trueを設定すると配列の次元が保たれる．
print(np.sum(a, axis=1, keepdims=True))
# [[1]
#  [5]]


# max関数
print(np.max(a))
# 3

print(np.max(a, axis=0))
# [2 3]


# argmax関数
# argmax関数は，最大値のインデックスを取得する．
print(np.argmax(a, axis=0))
# [1 1]


# where関数
# where関数は，配列に対して条件に基づき変更を加えて，新たな配列を作成する．
print(np.where(a<2, 9, a))
#[[9 9
# [2 3]]