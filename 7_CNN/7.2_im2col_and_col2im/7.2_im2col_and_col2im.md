[](2019/05/13)

## 7.2 im2colとcol2im
- 畳み込み層とプーリング層のコードをシンプルに保ち，実行速度を早く保つために，im2colおよびcol2imというアルゴリズムを用いる．
- <u>im2colは，画像を表す4次元配列を行列に変換し，col2imは行列を，画像を表す4次元配列に変換する．</u>

### 7.2.1 im2colとcol2imの概要
- 畳み込み層への入力は，バッチとチャンネルを考慮しなければ，次のようなシンプルな行列で表すことができる：

<center>
<img src="figures/input_image.png" width="250">
</center>

- しかしながら，実際にはバッチ学習，ミニバッチ学習に対応する必要があり，複数のチャンネルを持つRGB画像を扱う必要もある．
- バッチ，チャンネルに対応した入力画像を次に示す（$C$：入力画像のチャンネル数，$B$：バッチサイズ）：

<center>
<img src="figures/input_image_batch_channels.png" width="650">
</center>

- 上図に示すように，入力画像は4次元配列，すなわち4階のテンソルになる．

<br>

- そして，フィルタは複数あり，それぞれのフィルタのチャンネル数は入力画像のチャンネル数と同じになる：

<center>
<img src="figures/filter.png" width="350">
</center>

- 以上のように，畳み込み層を実装する際には多くの入り組んだ要素を考慮する必要があり，何重にも重なった多次元配列を扱う必要がある．
- <u>多次元配列をfor文などによるループで扱おうとすると，ループが幾重にもなりコードが複雑になってしまう．</u>
- <u>また，NumPyは，行列演算は高速だが，ループの実行にはとても時間がかかる．</u>
- そこで，ループを最小限に抑え，コードをシンプルに保つために用いるのが，im2colおよびcol2im：

<center>
<img src="figures/im2col_and_col2im.png" width="800">
</center>

- 順伝播の場合はim2col，逆伝播の場合はcol2imが用いられるが，これらのアルゴリズムにより実行時間のかかるループ処理を最小限に抑え，メインの計算を1つの行列積に集約させることが可能になる．
- im2colとcol2imは，プーリング層でも活用される．

<br>

### 7.2.2 im2colのアルゴリズム
- 畳み込みは，行列積として計算すると比較的シンプルなコードでおこなうことができる．
- <u>そのためには，入力画像を行列演算に適した形状に変形する必要があるが，im2colはその際に利用される．</u>
- また，プーリング層で各領域の最大値を抽出する際にも，im2colは利用される．
- im2colは簡潔さと実効速度で優れており，ディープラーニング用のライブラリ，ChainerやCaffeでも使用されている．

<br>

- im2colは，基本的に画像上の長方形の領域を行列の形に変換するアルゴリズム：

<center>
<img src="figures/im2col_algorithm.png" height="500">
</center>

- 左上から右に領域をスライドさせて，領域の要素を行列の列に変換していく．
- 領域が一番右に達した場合，領域を1つ下にスライドして再び左から右にスライドさせる．
- この結果，画像の行列に変換することができる．
- バッチとチャンネルを考慮しない場合，im2colにより生成される行列の形状は，次のように $(F_hF_w, O_hO_w)$ となる：

<center>
<img src="figures/im2col_matrix.png" width="700">
</center>

- 次に，入力画像がバッチとチャンネルに対応している場合を考える．
- <u>フィルタはチャンネルの数だけあり，出力はバッチサイズの数だけあるので，チャンネル数を $C$，バッチサイズを $B$ とすると，im2colにより生成される行列の形状は $(CF_hF_w, BO_hO_w)$ となる．</u>：

<center>
<img src="figures/im2col_matrix_batch_channel.png" width="700">
</center>

- このように，im2colを用いることで，バッチとチャンネルに対応している場合でも，単一の行列で入力画像を表現することができる．
- この行列とフィルタで行列積を計算するために，複数のフィルタを次のようにして1つの行列に格納する：

<center>
<img src="figures/filter_matrix.png" width="350">
</center>

- これをチャンネルに対応させると，すべてのフィルタを格納した行列は次のようになる：

<center>
<img src="figures/filter_matrix_channel.png" width="500">
</center>

- フィルタの数を $M$ とすると，行列の形状は $(M, CF_hF_w)$ となる．
- <u>この行列の列数 $CF_hF_w$ と，入力画像から生成した行列の行数 $CF_hF_w$ が一致することにより，行列積が可能となり，畳み込みの計算を一度に行うことができる．</u>
- この行列積を以下に示す：

<center>
<img src="figures/conv_by_matrix_product.png" width="900">
</center>

- 行列積の前の行列における各行は個々のフィルタで，後ろの行列における各列はそれらのフィルタが重なる領域．
- <u>行列積により生成された行列の形状は $(M, BO_hO_w)$ だが，これを $(B, M, O_h, O_w)$ に変換することで，畳み込み層の出力の形状になる．</u>

<br>

### 7.2.3 im2colの実装 -シンプルなim2col-